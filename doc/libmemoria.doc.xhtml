<?xml version="1.0" encoding="UTF-8" ?>
<!--
  - (COPYRIGHT) Copyright (C) 2008, 2009, The ONS Team.
  - This file is part of ONS, see COPYING for details.
  -->

<!--
  - File Information:
  - Created: 8. February 2009
  - Lead-Dev: - David Herrmann
  - Contributors: /
  - Last-Change: 22. February 2009
  -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Libmemoria - Open Network Suite - Official Documentation</title>
        <meta name="author" content="The ONS Team" />
        <meta name="description" content="Reference documentation of libmemoria." />
        <meta name="keywords" content="ons, open network suite, network, internet, open source, public domain" />
        <meta name="robots" content="index" />
        <style type="text/css">
        body {
            padding: 0px;
            margin: 50px;
            border: 0px;
            text-align: justify;
        }
        p {
            padding-left: 20px;
        }
        code {
            background-color: #FFBBBB;
        }
        </style>
    </head>
    <body>
        <div id="main">
            <div id="overview">
                <h1>Libmemoria</h1>
                <p>
                    Libmemoria is a memory library which provides memory allocators as well as memory structures like linked lists or hash tables.
                </p>
                <p>
                    To use libmemoria, simply include <code>&lt;memoria/memoria.h&gt;</code> in your source code.
                </p>
                <p>
                    Libmemoria depends on libons and a ISO-C library.
                </p>
                <p>
                    The following datatypes are used all over libmemoria:<br />
                    <ul>
                        <li>
                            <code>mem_index_t</code>: Defined as <code>size_t</code> and is used to index a single element in a list of elements.
                            It cannot overflow because your memory has at most <code>sizeof(size_t)</code> bytes of space.
                        </li>
                        <li>
                            <code>mem_hash_t</code>: A 32bit unsigned integer which holds a single hash value.
                        </li>
                    </ul>
                </p>
            </div>
            <div>
                <h2>Memory Allocators</h2>
                <p>
                    Libmemoria provides two different memory allocators. Each allocator can, like <code>malloc()</code>, allocate memory and later be
                    freed. All allocators never fail. If the backend fails, a callback is called and when this callback returns, the application is
                    aborted with a message to <code>stderr</code>. If the callback is <code>NULL</code>, no callback is called. It is declared the
                    following:<br />
                    <code>
                        <pre>
                            extern void (*mem_outofmem)(void);
                        </pre>
                    </code>
                    You should set the handler at the beginning of your program. But take into account that the handler must be reentrant if you call
                    the allocators in multiple threads. ONS itself is never multithreaded if you do not explicitly requests an operation to be
                    done in an extra thread.
                </p>
                <p>
                    If you allocated memory with one allocator, you have to free it with the same allocator. Never mix two allocators!
                </p>
                <p>
                    <h3><code>malloc()</code> based</h3>
                    <p>
                        This allocator is a simple wrapper for the <code>malloc()</code> interface. The following functions are available:<br />
                        <p>
                            <code>
                                <pre>
                                    void *mem_malloc(size_t size);
                                </pre>
                            </code>
                            <p>
                                Returns a pointer to the allocated space of <code>size</code> bytes. The global callback is called on failure. However,
                                this function never returns <code>NULL</code>. The behaviour is undefined if <code>size</code> is zero.
                            </p>
                        </p>
                        <p>
                            <code>
                                <pre>
                                    void *mem_zmalloc(size_t size);
                                </pre>
                            </code>
                            <p>
                                Exactly the same as <code>mem_malloc</code> but it initializes all the space to zero.
                            </p>
                        </p>
                        <p>
                            <code>
                                <pre>
                                    void *mem_realloc(void *mem, size_t size);
                                </pre>
                            </code>
                            <p>
                                Resizes the space where <code>mem</code> points to, to <code>size</code> bytes. The behaviour is unknown if
                                <code>size</code> is zero. This function calls the global callback on failure. However, it never returns NULL.<br />
                                It returns a pointer to the new space. <code>size</code> bytes of the old data are preserved. If <code>size</code>
                                is bigger than the current size of <code>mem</code>, all data in <code>mem</code> is copied to the new space.
                            </p>
                        </p>
                        <p>
                            <code>
                                <pre>
                                    void *mem_dup(const void *mem, size_t len);
                                </pre>
                            </code>
                            <p>
                                Duplicates the memory at <code>mem</code>. <code>len</code> is the length of <code>mem</code>. This function returns
                                a pointer to an exact memory copy of <code>mem</code>.
                            </p>
                        </p>
                    </p>
                </p>
                <p>
                    <h3><code>mmap()</code> based</h3>
                    <p>
                        <p>
                            The <code>mmap()</code> interface uses this system call to allocate a huge memory block with the <code>MAP_ANON</code>
                            functionality. The advantage is, that after freeing the allocated space the memory is guaranteed to be totally returned
                            to the OS. Though, modern <code>malloc()</code> implementations are much faster than this and should be preferred.<br />
                            This interface is considered obsolete. Please see the comments in <em>mem.h</em>, <em>heap.h</em> and
                            especially <em>heap.c</em> for more information and benchmarks.
                        </p>
                        <p>
                            <code>
                                <pre>
                                    void *mem_block_alloc(size_t size);
                                </pre>
                            </code>
                            <p>
                                Returns a memory block of <code>size</code> bytes. Calls the global callback on failure. It never returns NULL, however.
                                If <code>size</code> is 0, the behaviour is unknown.
                            </p>
                        </p>
                        <p>
                            <code>
                                <pre>
                                    void mem_block_free(void *ptr, size_t size);
                                </pre>
                            </code>
                            <p>
                                Frees a previously allocated memory block. It is important to pass the same size argument as in the allocator.
                            </p>
                        </p>
                    </p>
                </p>
            </div>
            <div>
                <h2>Dynamic Memory Structures (linear)</h2>
                <p>
                    Libmemoria provides several structures which can be used to manage a linear list of elements. This includes linked lists,
                    dynamic arrays, hash tables, ...<br />
                    <em>linear</em> means that all elements are ordered in a linear way in these structures. Therefore, you can iterate through all
                    elements like iterating through list. The other type is a <em>tree</em> structure and we will probably implement more types
                    in the future.
                </p>
                <p>
                    All linear types have some common behaviour. That is, the elements are saved in a linear list and you can insert and delete
                    elements. Inserting an element at the beginning of the list is called <strong>*_thrust()</strong>, inserting at the end is called
                    <strong>*_push()</strong> and inserting at an arbitrary position is called <strong>*_insert()</strong>.<br />
                    Removing the first elements is called <strong>*_shift()</strong>, removing the last elements is called <strong>*_pop()</strong> and
                    removing an arbitrary element is called <strong>*_remove()</strong>.<br />
                    Each implementation may provide some aliases for these functions which represent the functionality in a better way.<br />
                </p>
                <p>
                    <h3>Dynamic Array</h3>
                    <p>
                        The dynamic array is implemented as a normal array whose size is dynamically adjusted to the number of used elements. Therefore,
                        the physical address of an element is not constant and may change when the array needs to be reallocated to a bigger/smaller
                        size. You should always refer to an element with it's index and not with a pointer unless you know that the array is not touched
                        while you use this pointer. However, if you add/delete an element in the middle of the array, the indexes of the higher elements
                        increase/decrease.<br />
                        The fastest way is always pushing or poping the elements.<br />
                        Additionally, you can set two different options on each array. The first option <em>free</em> controls whether the memory should
                        be reallocated to a smaller size when you remove elements in the array. If this options is <em>false</em>, then the allocated
                        space is never decreased.<br />
                        The second option <em>double</em> controls the allocation behaviour. To prevent many memory allocations, the implementation
                        allocates always a specified amount of elements and keeps the unused elements at the top of the stack, so if you add a new
                        element to the list, we do not need to allocate memory and can just use the unused elements at the top. This option now controls
                        how many elements are allocated at once. You can specify a number of elements which are allocated when the array is created.
                        The normal behaviour is, that this number is always added to the current number of elements when the array needs to be
                        incremented. So if you specified 4 as the first number of elements, the array is reallocated every 4 elements:<br />
                        4, 4 + 4, 8 + 4, 12 + 4, 16 + 4, ...<br />
                        But if this option is true, the number of elements is always doubled. In this case this would be:<br />
                        4, 4 * 2, 8 * 2, 16 * 2, 32 * 2, ...<br />
                        The advantage of each method should be clear, though, you should decide on a per case basis which one is best.
                    </p>
                    <p>
                        Sorting functions are not provided by libmemoria, though, you should use the <code>qsort()</code> function as provided by the
                        ISO-C89 standard.
                    </p>
                    <p>
                        <h4>Generic Array</h4>
                        <p>
                            This is the reference implementation of the dynamic array. It is based on the following array structure:<br />
                            <code>
                                <pre>
                                    typedef struct mem_array_t {
                                        mem_index_t reserve;
                                        mem_index_t size;
                                        mem_index_t used;
                                        size_t element;
                                        void *list;

                                        unsigned int opt_free : 1;
                                        unsigned int opt_double : 1;
                                    } mem_array_t;
                                </pre>
                            </code>
                            Create a <code>mem_array_t</code> structure on the stack/heap and initialize it with the following function:<br />
                            <code>void mem_array_init(struct mem_array_t *array, size_t element, mem_index_t reserve)</code><br />
                            This sets <code>reserve</code> and <code>element</code> to the given values.<br />
                            <code>mem_array_t.reserve</code> is the number of elements which are allocated when the array is created.<br />
                            <code>mem_array_t.size</code> is the current size of allocated elements. This can be greater or equal to the current
                            number of used elements.<br />
                            <code>mem_array_t.used</code> is the current number of used elements.<br />
                            <code>mem_array_t.element</code> is the size of the type which is stored in this array.<br />
                            <code>mem_array_t.list</code> is <code>NULL</code> if <code>used</code> is 0, otherwise it points to the first element
                            in the array.<br />
                            <code>opt_free</code> and <code>opt_double</code> are the options as described above.<br />
                            <em>You should never modify any of these values directly, except the options, however, you can access the array with the
                            <code>list</code> pointer. The options <strong>can safely</strong> be modified at any time.</em>
                            If <code>element</code> or <code>reserve</code> are 0, they are automatically set to 1.
                        </p>
                        <p>
                            <code><pre>void mem_array_clear(struct mem_array_t *array);</pre></code><br />
                            This function frees all elements in the array and sets the <code>list</code> pointer to <code>NULL</code>. You can safely
                            allocate new elements in this array after clearing it.
                        </p>
                        <p>
                            Several macros are available to access an element at an index.<br />
                            <code><pre>#define MEM_ARRAY_INDEX(mem_array_t *array, void *ele)</pre></code><br />
                            <code>ele</code> should point to an element in <code>array</code>. This macro returns the related index.<br />
                            <code><pre>#define MEM_ARRAY(mem_array_t *array, mem_index_t index)</pre></code><br />
                            Returns a pointer to the element at the given index. The returned pointer is of type <code>void*</code>.<br />
                            <code><pre>#define MEM_TYPE(mem_array_t *array, mem_index_t index, TYPE)</pre></code><br />
                            Same as <code>MEM_ARRAY</code> but casts the returned <code>void*</code> pointer to <code>TYPE</code>. Obviously,
                            <code>TYPE</code> should also be an pointer type.<br />
                            <code><pre>#define MEM_DEREF(mem_array_t *array, mem_index_t index, TYPE)</pre></code><br />
                            Same as <code>MEM_TYPE</code>, but it returns directly the dereferenced object and not a pointer. Therefore,
                            <code>TYPE</code> should not be a pointer type unless you save pointers in this array.
                        </p>
                        The following functions are available to insert an element to the array. All these functions return a <code>void*</code>
                        pointer to the new element. These functions never fail.
                        <p>
                            <code><pre>
                                void *mem_array_push(struct mem_array_t *array);
                                void *mem_array_insert(struct mem_array_t *array, mem_index_t index);
                                void *mem_array_thrust(struct mem_array_t *array);
                            </pre></code><br />
                            <code>*_push()</code> inserts at the end, <code>*_thrust()</code> at the beginning and <code>*_insert()</code> adds the
                            element at the index <code>index</code>.
                        </p>
                        The following functions are used to delete elements from the array. They never fail.
                        <p>
                            <code><pre>
                                void mem_array_pop(struct mem_array_t *array);
                                void mem_array_remove(struct mem_array_t *array, mem_index_t index);
                                void mem_array_shift(struct mem_array_t *array);
                            </pre></code>
                            <code>*_pop()</code> removes the last element, <code>*_shift()</code> removes the first element and <code>*_remove()</code>
                            removes the element at the position <code>index</code>.
                        </p>
                    </p>
                    <p>
                        <h4>Template Array</h4>
                        <p>
                            This array implementation is nearly the same as the generic one, but is adjusted to a specific datatype. This means, instead
                            of using <code>void*</code> you can use a macro to define all the functions described above with a specific datatype.<br />
                        </p>
                        <p>
                            <code><pre>MEM_ARRAY_DEFINE(ARR_NAME, ELE_TYPE, INITIAL_VAR, FREE, DOUBLE)</pre></code><br />
                            Declares all the necessary functions and datatypes. <code>ARR_NAME</code> will be the name of the array structure and the
                            prefix of the functions. <code>ELE_TYPE</code> should be the datatype of the element you want to store in the array.
                            <code>INITIAL_VAR</code> is an unsigned integer value which specifies the initial amount of elements. <code>FREE</code>
                            and <code>DOUBLE</code> are the boolean options as described above.<br />
                            This defines the following structure:<br />
                            <code><pre>
                                    typedef struct ARR_NAME {
                                        mem_index_t used;
                                        mem_index_t size;
                                        ELE_TYPE *list;
                                    } ARR_NAME;
                            </pre></code>
                            The members have the same meaning as in the structure of the generic implementation.
                            Furthermore, it declares the same six functions as described above, but with the array name as the prefix. This would be
                            for instance: <code>ARR_NAME_push(... parameters ...)</code>.<br />
                            The macros to access a special element cannot be used here, however, you can use the <code>[]</code> brackets directly on
                            the <code>list</code> member.
                        </p>
                    </p>
                    <p>
                        Both dynamic array implementations force you to allocate the base structure yourself. However, this has one advantage. If you
                        want to return an array in a function, you can use this interface by allocating the base structure on the stack and filling
                        the array. When you want to return the array, you simply return the <code>list</code> pointer. The structure is dynamically
                        deallocated by the stack and you simply have to call <code>mem_free()</code> on the returned pointer to free all memory still
                        related to this array.
                    </p>
                </p>
                <p>
                    <h3>Double Linked Lists</h3>
                    <p>
                        Linked lists should be known to every developer. They are easy to implement and allow uge lists of elements without much
                        overhead. However, searching in linked lists is slow and you should prefer other mechanisms like hashtables if you often search
                        in a list.<br />
                        Libmemoria has a generic double linked list implementation which can be used with any datatype. You simply have to allocate a
                        base structure which manages the linked list. The datatype which you want to store in the linked list must be a structure and
                        must have a special member which contains the <code>next</code> and <code>prev</code> links. You have to allocate the elements
                        yourself, libmemoria provides only functions to insert an element into the list and to unlink it from the list.
                    </p>
                    <p>
                        The base structure is defined as:<br />
                        <code><pre>
                            typedef struct mem_list_t {
                                size_t offset;
                                struct mem_node_t *nodes;
                                size_t count;
                                mem_match_t match;
                            } mem_list_t;
                        </pre></code><br />
                        This structure can handle a list of exactly one datatype. This datatype has to look like the following:<br />
                        <code><pre>
                            struct &lt;arbitrary_name&gt; {
                                &lt;... zero or more arbitrary members ...&gt;
                                mem_node_t &lt;arbitrary_name&gt;;
                                &lt;... zero or more arbitrary members ...&gt;
                            };
                        </pre></code><br />
                        This means the structure you want to save in this list must have a <code>mem_node_t</code> member. <strong>This member must not be
                        a pointer!</strong>.<br />
                        Whereas <code>mem_node_t</code> is implemented as the following:<br />
                        <code><pre>
                            typedef struct mem_node_t {
                                struct mem_node_t *next;
                                struct mem_node_t *prev;
                                struct mem_list_t *head;
                            } mem_node_t;
                        </pre></code><br />
                        The usage can be best shown with an example:<br />
                        <code><pre>
                            struct i_am_saved {
                                int value1;
                                char *value2;
                                short value3[10];
                                mem_node_t llist_node;
                            };

                            int main() {
                                mem_list_t list;

                                MEM_LL_INIT(&amp;list, struct i_am_saved, llist_node);

                                /* Now work with the list. Insert and remove elements of type "struct i_am_saved". */
                            }
                        </pre></code><br />
                        Now, you need to know more details about the structures. First, the <code>mem_list_t</code> structure. The <code>offset</code>
                        member contains an integer which specifies the offset of the <code>mem_node_t</code> member in the element-structure. This is
                        automatically set and you should never touch it. <code>nodes</code> points to the first member of the linked list or is
                        <code>NULL</code> if the list is empty. <code>count</code> contains the number of currently stored elements and
                        <code>match</code> is the function which is used to sort the elements. It is explained below. The <code>mem_node_t</code>
                        structure has two members which point to the next and the previous <code>mem_node_t</code> element in the list. The
                        <code>head</code> member points to the base structure of the list.<br />
                        In detail, the list stores <code>mem_node_t</code> structures in this list, but the base structure has the information to get
                        the corresponding <code>i_am_saved</code> structure (the structure defined by the user) out of a <code>mem_node_t</code>
                        structure.
                    </p>
                    <p>
                        As shown in the example above, you can initialize a linked list with a macro:<br />
                        <code>#define MEM_LL_INIT(mem_list_t *list, TYPE, NODE_NAME);</code><br />
                        <code>list</code> must point to an uninitialized linked list base structure. <code>TYPE</code> must be the datatype which is
                        stored in the linked list and <code>NODE_NAME</code> must be the name of the <code>mem_node_t</code> member in the
                        <code>TYPE</code> structure. This macro internally calls:<br />
                        <code>void mem_ll_init(mem_list_t *list, size_t offset)</code><br />
                        whereas <code>list</code> is the same as in the macro, but <code>offset</code> is defined as <code>offsetof(TYPE, NODE_NAME)</code>.
                        <code>offsetof()</code> is a builtin construct of ISO-C89.
                    </p>
                    <p>
                        The following functions are defined to insert a new element into the list. We take as example the <code>struct i_am_saved</code>
                        from the example above as a user defined structure which is stored in the list. If these functions take a <code>void*</code>
                        pointer as argument or return a <code>void*</code> pointer, it is always meant to be the datatype of the user, which is here
                        the <code>struct i_am_saved</code>.<br />
                        <code><pre>
                            void *mem_ll_prepend(mem_list_t *list, void *raw_member, void *raw_newm);
                            void *mem_ll_append(mem_list_t *list, void *raw_member, void *raw_newm);
                            void *mem_ll_thrust(mem_list_t *list, void *raw_newm);
                            void *mem_ll_push(mem_list_t *list, void *raw_newm);
                        </pre></code><br />
                        <code>list</code> points to the list which is to be modified. <code>raw_newm</code> is the pointer to the member which should
                        be inserted into the list. It is not copied! It must be allocated by the user before.<br />
                        <code>raw_member</code> is always an already inserted member which is taken as insertpoint.<br />
                        <code>*_prepend()</code> inserts the member before the insertpoint. If the insertpoint is the first member, then the new
                        member becomes the first member.<br />
                        <code>*_append()</code> inserts the member after the insertpoint. If the insertpoint is the last member, then the new member
                        becomse the last member.<br />
                        <code>*_thrust()</code> inserts the member as new first member.<br />
                        <code>*_push()</code> inserts the member as new last member.<br />
                        Each of these four ways is as fast as the other three ways. Each function returns always <code>raw_newm</code>.
                    </p>
                    <p>
                        The following functions are defined to unlink an element from a list. Please take into account, that the element is not freed.
                        Each function returns a pointer to the unlinked member.<br />
                        <code><pre>
                            void *mem_ll_remove(mem_list_t *list, void *raw_member);
                            <em>alias for mem_ll_remove: mem_ll_extract();</em>
                            void *mem_ll_shift(mem_list_t *list);
                            void *mem_ll_pop(mem_list_t *list);
                        </pre></code><br />
                        <code>*_remove()</code> removes the given member from the list and returns <code>raw_member</code>.<br />
                        <code>*_shift</code> removes the first element from the list and returns it. If the list is empty, it returns NULL.<br />
                        <code>*_pop</code> removes the last element from the list and returns it. If the list is empty, it returns NULL.<br />
                    </p>
                    <p>
                        The following functions and macros can be used to manage elements:<br />
                        <code><pre>
                            #define mem_ll_empty(const mem_list_t *list);
                            void *mem_ll_entry(const mem_node_t *node);
                            #define MEM_LL_ENTRY(mem_node_t *node, TYPE) ((TYPE)mem_ll_entry(node))
                            void *mem_ll_first(const mem_list_t *list);
                            void *mem_ll_last(const mem_list_t *list);
                        </pre></code><br />
                        <code>*_empty()</code> returns true, if the list is empty, otherwise false.<br />
                        <code>*_entry()</code> returns the user defined structure which holds the given node structure.<br />
                        <code>*_ENTRY()</code> is a convenience macro for the <code>*_entry()</code> functions which additionally casts the returned
                        <code>void*</code> pointer to <code>TYPE</code>.<br />
                        <code>*_first()</code> returns a pointer to the first element. If the list is empty, it returns <code>NULL</code>.<br />
                        <code>*_last()</code> returns a pointer to the last element. If the list is empty, it returns <code>NULL</code>.<br />
                    </p>
                    <p>
                        The linked list allows also to keep the list sorted. It uses a special callback function which compares two elements and returns
                        which one of them is bigger/smaller or whether they are equal. Equal elements are stored in no particular order in the sorted
                        list.<br />
                        The callback is defined as:<br />
                        <code>typedef ons_comp_t (*mem_match_t)(const void *orig, const void *comparison);</code><br />
                        You have to manually set the <code>match</code> member in your <code>mem_list_t</code> structure to your function. If no such
                        function is defined (<code>match == NULL</code>), but you try to sort the list, then the physical addresses of the elements are
                        compared.<br />
                        <em>A sorted list is always kept in ascending order!</em><br />
                        That is, the first element of a sorted list is the smallest and the last element is the biggest. If you want to store the
                        elements in descending order, just return the reversed values in your <code>match</code> function.<br />
                        An example with the <code>struct i_am_saved</code> user structure would be:<br />
                        <code><pre>
                            ons_comp_t func_match(const struct i_am_saved *orig, const struct i_am_saved *comparison) {
                                /* We sort by the integer value1. */
                                if(comparison->value1 &gt; orig->value1) return ONS_GREATER;
                                else if(comparison->value1 &lt; orig->value1) return ONS_SMALLER;
                                else return ONS_EQUAL;
                            }

                            /* elsewhere */
                            your_list->match = func_match;
                        </pre></code><br />
                        To keep a list sorted, you have to insert the elements with special functions or sort the list manually. That is, either insert
                        them with the functions described above and afterwards call:<br />
                        <code>void mem_ll_sort(mem_list_t *list);</code><br />
                        which will then sort the list with a simple Insertion-Sort algorithm or you insert the elements sorted into the list with:<br />
                        <code><pre>
                            void *mem_ll_srtd_prepend(mem_list_t *list, void *raw_member);
                            void *mem_ll_srtd_append(mem_list_t *list, void *raw_member);
                        </pre></code><br />
                        Both functions insert <code>raw_member</code> sorted into the list and return it. They differ in the behaviour if there is
                        already an element in the list which equals <code>raw_member</code>. <code>*_prepend()</code> will insert it before all other
                        equal elements and <code>*_append()</code> will insert it after all equal elements.
                    </p>
                </p>
            </div>
            <div>
                <h2>Dynamic Memory Structures (block based)</h2>
                <p>
                    Libmemoria provides one block-based memory structure called <em>heap</em>. This heap works the following way:<br />
                    You create a new heap which is used to store elements of a specified datatype. The size of the datatype must be fixed. Now, you can
                    allocate such elements from this heap and use them. They are neither linked in a list nor ordered in an array, quite contrary, they
                    have as much information as if you requested them with <code>mem_malloc()</code> => nothing.<br />
                    However, the heap allocates huge memory blocks and if you request a new element, it does not have to allocate new memory but can
                    just return one of the temporary objects it holds. If one such block is full, it allocates a new block and if one block gets empty,
                    it deletes the whole block.<br />
                    You may ask what the benefits are when you use this interface. Well, this is hard to say, because this interface is when used
                    instead of <code>mem_malloc()</code> almost twice as slow and not recommended here. However, this interface has some advantages.
                    If you want to allocate many objects for a short time and then delete all of them, you can allocate them with this interface,
                    without keeping track if the elements and then, if you do not need them, anymore, you just delete the whole heap which deallocates
                    all objects.<br />
                    Another advantage is, that this interface uses the <code>mmap()</code> backend as described above. That is, the memory is returned
                    to the operating system when a block gets freed.<br />
                    The file <em>heap.c</em> contains benchmarks and shows that this interface is obsolete if you want to replace
                    <code>mem_malloc()</code>, though, you can use it, as I said, if you don't want to care for free()'ing the objects.<br />
                </p>
                <p>
                    To use this heap you have to create a new heap object. This is done with:<br />
                    <code>mem_heap_t *mem_heap_create(size_t node_size, unsigned long nodes_per_block);</code><br />
                    Whereas <code>node_size</code> is the size of a single object you want to store in this heap and <code>nodes_per_block</code>
                    specifies how many elements are allocated at once. It never fails! Both values are set to 1 if you specified 0.<br />
                    You can delete such an heap object with:<br />
                    <code>void mem_heap_destroy(mem_heap_t *heap);</code><br />
                    This frees all allocated objects in this heap and finally frees the heap itself.<br />
                </p>
                <p>
                    If you created an heap object you can allocate elements with:<br />
                    <code>void *mem_heap_alloc(mem_heap_t *heap);</code><br />
                    This returns a pointer to a new element. It never fails, though, <code>heap</code> must not be <code>NULL</code>. You can manually
                    free it with:<br />
                    <code>void mem_heap_free(mem_heap_t *heap, void *mem);</code><br />
                </p>
            </div>
            <div>
                <h2>Hash Functions</h2>
                <p>
                    Libmemoria provides no hash tables, but it provides hash functions. Currently, only one hash algorithm is implemented, but in
                    future other algorithms may be available.<br />
                    If you don't know how to create a hashtable out of a hashfunction, you're probably at the wrong place here. However, the tutorials
                    contain a reference hash table implementation. This is probably what you search.<br />
                </p>
                <p>
                    If you want to hash an arbitrary dataset, you can use our hash function:<br />
                    <code>mem_hash_t mem_hash(const char *str, size_t len);</code><br />
                    <code>str</code> must point to the data of size <code>len</code>. It does not have to be terminated by a zero character and can
                    contain as many zero characters as you want.<br />
                    The returned hash value is a 32bit integer.<br />
                    <em>This function is not cryptographically secure.</em>
                </p>
            </div>
            <div>
                <h2>RNGs - Random Number Generators</h2>
                <p>
                    Libmemoria provides some cryptographically secure and insecure (but faster) pseudo random number generators.
                </p>
                <p>
                    <h3>ISAAC+</h3>
                    <p>
                        ISAAC+ was invented by Bob Jenkins and the algorithm is under the public domain. You can create this RNG by allocating the base
                        structure:<br />
                        <code><pre>
                            typedef struct mem_isaac_t {
                                uint32_t randcnt;
                                uint32_t randrsl[256];
                                uint32_t randmem[256];
                                uint32_t randa;
                                uint32_t randb;
                                uint32_t randc;
                            } mem_isaac_t;
                        </pre></code>
                        The members are not of interest and represent temporary values of the algorithm. You can always override the array
                        <code>randrsl</code> with entropy but this is not required.<br />
                        You can initialize this structure with:<br />
                        <code><pre>
                            void mem_isaac_seed(mem_isaac_t *r);
                        </pre></code>
                        The array <code>randrsl</code> of the base structure is taken as seed value. Seeding it with the current time in microseconds
                        is often sufficient.<br />
                        You can generate a new 32bit random number with:<br />
                        <code>uint32_t mem_isaac_rand(mem_isaac_t *r);</code><br />
                        Internally, 256 random numbers are generated at once. They are returned by this function and if you called this function 256
                        times, the next 256 random numbers are generated.<br />
                        The function which generates the next 256 random numbers can also be called manually:<br />
                        <code>void mem_isaac_gen(mem_isaac_t *r);</code><br />
                    </p>
                    <p>
                        This ISAAC+ RNG is cryptographically secure!
                    </p>
                </p>
                <p>
                    <h3>Insecure RNG</h3>
                    <p>
                        This RNG is twice as fast as ISAAC+ but is not cryptographically safe. Though, it is sufficient in most cases.
                    </p>
                    <p>
                        Simply allocate the following base structure:<br />
                        <code><pre>
                            typedef struct mem_rand_t {
                                uint32_t a;
                                uint32_t b;
                                uint32_t c;
                                uint32_t d;
                            } mem_rand_t;
                        </pre></code><br />
                        And seed it with the following function:<br />
                        <code>void mem_seed(mem_rand_t *x, uint32_t seed);</code><br />
                        <code>seed</code> should be a 32bit random number which is used to seed the RNG. The current time in microseconds is always a
                        good choice.<br />
                        You can get the next random number with:<br />
                        <code>uint32_t mem_rand(mem_rand_t *x);</code><br />
                    </p>
                </p>
            </div>
        </div>
    </body>
</html>
