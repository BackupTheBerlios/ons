<?xml version="1.0" encoding="UTF-8" ?>
<!--
  - (COPYRIGHT) Copyright (C) 2008, The ONS Team.
  - This file is part of ONS, see COPYING for details.
  -->

<!--
  - File Information:
  - Created: 3. January 2009
  - Lead-Dev: - David Herrmann
  - Contributors: /
  - Last-Change: 7. February 2009
  -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Open Network Suite - Official Documentation</title>
        <meta name="author" content="The ONS Team" />
        <meta name="description" content="Documentation of the Open Network Suite." />
        <meta name="keywords" content="network, internet, ipv4, ipv6, communication, open source, public domain, tcp, udp, dns" />
        <meta name="robots" content="index" />
        <style type="text/css">
        body {
            padding: 0px;
            margin: 50px;
            border: 0px;
            text-align: justify;
        }
        </style>
    </head>
    <body>
        <div id="main">
            <div id="overview">
                <h1>Overview</h1>
                <p>
                    The Open Network Suite is a bundle of libraries which are created to help managing all kind of network issues. They are
                    written in plain C and intended to run smoothly and fast, even on embedded devices. Furthermore, the whole source is available
                    under the Public Domain which allows you to use it for all purposes.<br />
                    The Open Network Suite (foll. "ONS") is divided into subgroups where each subgroup represents one library of ONS. The
                    subgroups are referred here with or without the prefix "lib" (eg., "memoria" or "libmemoria").<br />
                    The main library is called "libons". It does not provide any special functionality but contains wrappers for some system
                    dependent functions which are needed in more than one ONS library. This library is required for all other libraries of ONS.
                    Moreover, if this library runs on you system, all other libraries are guaranteed to run on your system, too. Though, there
                    is no need to install all libraries. You can choose the libraries you need and install only them into your system.
                </p>
                <p>
                    The main applications for ONS are all kinds of network issues. All libraries are designed to have a simple API to do simple
                    things and to have a complex API to do complex things. Thus, you can use ONS for simple network communications (eg., writing
                    a protocol parser for your favourite instant messaging program) or even for writing network sniffers which operate on the raw
                    socket layer.<br />
                    However, the main reason to use ONS is that ONS is totally operating system independent. If you use ONS and ONS is available
                    for your platform, you don't have to care for any system dependent issues. Moreover, you can even handle really ONS dependent
                    issues in a uniform manner. Libons additionally provides some wrappers for network unrelated functionality.
                </p>
                <p>
                    This documentation is divided into several parts. You can skip all parts you don't need, however, I recommend to every developer,
                    who uses ONS, reading this file completely. For all others it is sufficient to read the installation guide.
                </p>
            </div>

            <div id="install">
                <h1>Installation</h1>
                <p>
                    ONS uses the GNU autotools for the configuration and compilation of the source. However, there are systems like Microsoft Windows
                    which do not support the GNU autotools natively. We provide separated Makefiles for these systems.<br />
                    The following list contains all supported operating systems. If the system does not support the GNU autotools, you should
                    use the makefile listed behind the system's name. The Makefiles are located in "./libraries". Generally, all architectures
                    are supported by ONS. Though, we test only on 64bit Intel (em64t) and AMD (amd64) machines.
                    <ul>
                        <li>Microsoft Windows NT and newer: (Makefile.win32)</li>
                        <li>Linux 2.4 and newer: (autotools)</li>
                        <li>Fully POSIX compatible systems: (autotools)</li>
                    </ul>
                    If your system is not listed here but supports GNU autotools, you should simply try using it. We have inofficial support for
                    systems like AIX, X-BSD, HP-UX, Solaris, SunOS, BeOS and MacOS-X. However, we have currently no time/machines where we could
                    test these systems, though, we would be glad to get any feedback of users using such systems.
                </p>
                <p>
                    <h2>Compiling without Autotools</h2>
                    If your system does not support GNU autotools you should use one of our extra makefiles. If no such makefile is available for your
                    system please read another one and try to create one for you system. You can always contact us and ask for support. If you have
                    created a makefile or there is one provided by us, you need to configure ONS for your system. The configuration file is located
                    in "./libraries/ons/include/ons/misc.h". You should read this file carefully, it should be self-explaining. The file has already
                    some auto-system-detecting.<br />
                    Now you need to invoke "make -f your_makefile.xyz" in the "./libraries" directory and the library should be built now. The makefile
                    contains comments whether install routines are supported, otherwise read the makefile carefully and copy the headers and binaries
                    listed there into your system's directories.
                </p>
                <p>
                    <h2>Compiling with Autotools</h2>
                    If your system supports GNU autotools the compiling process is much easier. If you got the source from the official repository,
                    you should first create the autoconf/make files. You can do this with "autoreconf -i" in "./libraries". If you got the source
                    from an official distribution of ONS, you do not need to do this task. Now, when these files (at least the "configure" script file)
                    are created you should invoke the standard autotools tasks:<br />
                    <ul>
                        <li>cd ./libraries</li>
                        <li>./configure --help=short</li>
                        <li>./configure [possibly some arguments]</li>
                        <li>make</li>
                        <li>su -</li>
                        <li>make install</li>
                        <li>exit</li>
                    </ul>
                    You should check the summary at the end of the configure output carefully and pass some arguments to configure if the output is
                    not correct. If everything built fine, ONS is now usable on your system.
                </p>
            </div>

            <div id="contact">
                <h1>Contact</h1>
                <p>
                    ONS is an OpenSource development. Though, the reason why we develop OpenSource and even in PublicDomain is very interesting, this
                    is not in the scope of this document. However, in our opinion OpenSource implies an "end-user near" development, i.e. we are glad
                    about <strong>every</strong> feedback we get from our users. We even want you to write us all of your questions, ideas, problems
                    with ONS. That is, if you reject using ONS because there is some annoying API you don't like but you haven't contacted us, we
                    can't improve our library and can't adjust the API to your needs.<br />
                    <strong>So, please don't hesitate to contact us!</strong><br />
                    <br />
                    You can contact us here:<br />
                    <ul>
                        <li>Visit us at: <a href="http://ons.berlios.de">ons.berlios.de</a></li>
                        <li>Send a mail to: ons@xccd.eu</li>
                    </ul>
                    You can also contact us on an unofficial way by going on IRC and talk
                    with one of us either in the query or in one of the listed channels. Our nicks
                    are listed in COPYING behind the real names.<br />
                    (sorted in descending availability)
                    <ul>
                        <li>irc.onlinegamesnet.net - #linux or #c++</li>
                        <li>irc.quakenet.org - #c or #c.de</li>
                        <li>irc.gamesurge.net - #coders</li>
                    </ul>
                    We are neither operators nor well known regulars on most of these channels.
                    Best way is just querying us.
                </p>
            </div>

            <div id="documentation">
                <h1>Documentation</h1>
                <p>
                    Have you really read the <a href="#contact"><em>Contact</em></a> part? No? READ IT!
                </p>
            </div>

            <div id="detail">
                <h1>Detailed look into the Open Network Suite</h1>
                <p>
                    As said before, ONS consists of several mostly stand-alone libraries which only partly depend on each other. Thus, this file does not
                    contain a reference for all libraries, but tries to give an overview about the structure used behind the whole software. Furthermore
                    it contains tutorials which help you learning how the libraries are used and how they work together and interact with each other. Though,
                    if you want to have a detailed function reference of a library, please read the reference documentations in this directory of the library
                    you want to get information of.
                </p>
            </div>

            <div id="tutorials">
                <h1>Tutorials</h1>
                <p>
                    Following, some tutorials which first show how to use the single libraries and then list more detailed views into the interaction between the
                    libraries and show how to use even complex functionality of ONS.
                </p>
                <div>
                    <h2>Libons - Functionality</h2>
                    <p>
                        The main functions which are provided by Libons are configuration of your system and macros providing such information in the source code.
                        One example are macros providing unpadded structures. Either "#pragma pack" or a structure attribute is supported, thus, simply use
                        both like:<br />
                        <code>
                            <pre>
            #include &lt;ons/ons.h&gt;

            #ifdef ONS_CONF_HAVE_PRAGMA_PACK
                #pragma pack(push)
                #pragma pack(1)
            #endif
            struct sample_structure {
                uint8_t val1;
                uint16_t val2;
                uint32_t val3;
                uint64_t val4;
            } ONS_ATTR_PACK;
            #ifdef ONS_CONF_HAVE_PRAGMA_PACK
                #pragma pack(pop)
            #endif
                            </pre>
                        </code>
                        This would create the structure "struct sample_structure" without any padding between the members. If the structure attribute is not supported
                        then "ONS_ATTR_PACK" is defined as nothing.
                        This is one example how system dependent functionality is provided through Libons. Though, this example provides two mechanisms for one result,
                        most other examples are <em>real</em> wrappers which are easier to use. Please see the Libons reference for all constants and macros.
                    </p>
                    <p>
                        Furthermore, Libons provides also a thread wrapper. It allows you to start a function of type <code>void *function(void *);</code> as a thread
                        and to wait (join) for this thread to exit. Return values are currently not supported, though, you can use variables to pass values between
                        threads. Also mutexes are supported to synchronize two or more threads.<br />
                        This example shows how to start a thread which counts from a start value and returns the current value when the other threads wants it to exit:
                        <code>
                            <pre>
            #include &lt;ons/ons.h&gt;
            #include &lt;stdio.h&gt;

            ons_mutex_t mutex;
            unsigned int val;
            void *callback(void *arg);

            void *callback(void *arg) {
                unsigned int *begin = arg;

                val = *begin;
                while(1) {
                    /* Do we need to return? */
                    if(!ons_mutex_trylock(&amp;mutex)) {
                        return NULL;
                    }

                    ++val;
                    ons_mutex_unlock(&amp;mutex);
                }
            }

            int main() {
                ons_thread_t thread;
                unsigned int begin = 10;

                /* Start thread an let him count from 10 upwards. */
                ons_mutex_init(&amp;mutex);
                ons_thread_run(&amp;thread, callback, &amp;begin);

                /* Now sleep 1 second and then lock the mutex and wait for the thread to exit. */
                ons_sleep(1);
                ons_mutex_lock(&amp;mutex);
                ons_thread_join(&amp;thread);

                ons_mutex_unlock(&amp;mutex);
                ons_mutex_free(&amp;mutex);

                printf("Thread counted: %u\n", val);

                return 0;
            }
                            </pre>
                        </code>
                    </p>
                    <p>
                        Libons provides much more such functionality. Though, the thread-wrapper is the most complex one (well, it isn't really complex). Following a
                        list of the other functions available through Libons. Please read the <a href="libons.doc.xhtml">ONS reference</a> for all information.<br />
                        <ul>
                            <li>Configuration constants for several options.</li>
                            <li>POSIX error code wrappers for WinSock error codes.</li>
                            <li>gettimeofday()'ish interface; getting the current time in seconds and microseconds.</li>
                            <li>htonX() and ntohX() for 16, 32 and 64 bit integers.</li>
                            <li>Unpadded structures.</li>
                            <li>Bit-Operating macros; Rotating an integer or setting a specific bit.</li>
                            <li>Global Open Network Suite error handling.</li>
                            <li>(De)Initializing functions.</li>
                        </ul>
                        The last point needs probably a short explanation. Some operating systems (like Microsoft Windows) need to initialize some core functions
                        before using them. Libons provides two functions: <code>ons_init(opts)</code> and <code>ons_deinit(opts)</code> which both take as argument
                        a bitflag with options which specify which options to initialize/deinitialize. Both functions are not reentrant and you should call them before
                        creating the first thread an after stopping the last additional thread.
                    </p>
                </div>
                <div>
                    <h2>Memoria - Functionality</h2>
                    <p>
                        Libmemoria is a memory management library. It provides generic linked lists, generic dynamic arrays and other generic and dynamic memory
                        structures. The following list shows all things supported by Libmemoria, please see the reference for a more detailed list, this document
                        shows only some tutorials for chosen topics:<br />
                        <ul>
                            <li>malloc(), realloc(), ... wrappers.</li>
                            <li>strnlen() and similar non-ISO-C string functions.</li>
                            <li>generic dynamic arrays</li>
                            <li>generic double linked lists</li>
                            <li>Heap management through mmap().</li>
                            <li>Fast hashing functions.</li>
                            <li>Fast cryptographic and non-cryptographic random number generators.</li>
                        </ul>
                    </p>
                    <p>
                        TODO: tutorials
                    </p>
                </div>
                <div>
                    <h2>Saw - Functionality</h2>
                    <p>
                        Saw was created when we tried to compile our socket application on a BSD machine and discovered that we need to check for BSD specific
                        members in the sockaddr structure, before we could use it. We decided to write a small library which checks for all these spcecial
                        cases on really not-standard-following UNIX systems. And while writing this library we discovered that there is really no system which
                        followes all POSIX/UNIX standards (this sucks!) and of course these standards are far less than perfect. However, this library supports
                        the following:<br />
                        <ul>
                            <li>Unpadded binary compatible address structures.</li>
                            <li>Converters to the common socket address structures on all supported systems.</li>
                            <li>Checks for special addresses, eg., solicited multicast.</li>
                        </ul>
                    </p>
                    <p>
                        TODO: tutorials
                    </p>
                </div>
                <div>
                    <h2>Fip - Functionality</h2>
                    <p>
                        Fip is a library which wraps the common Unix socket functions in a uniform API. Though, most UNIX systems follow a standard here, the returned
                        error codes are fare less than self-explaining and documented. The main reason why using Fip is because it returns the same codes on all machines
                        and documents what they mean and how to handle them. However, even the operating system's documentations do not list them so it is not
                        guaranteed that the error codes are comlete, but we show also ways to handle unknown error codes. Additionally, we support a wide spread amount
                        of socket options like dual-stack mode and, of course, nonblocking sockets. Furthermore, ancillary data transmission and interface binding
                        is supported. The following list shows the whole functionality:<br />
                        <ul>
                            <li>Socket error code wrapper.</li>
                            <li>Berkeley socket interface wrapper.</li>
                            <li>Socket options interface.</li>
                            <li>Ancillary data transmission.</li>
                            <li>Interface bindings.</li>
                        </ul>
                    </p>
                    <p>
                        TODO: tutorials
                    </p>
                </div>
                <div>
                    <h2>yaadns - Functionality</h2>
                    <p>
                        Yaadns is the try to create a DNS resolver library which supports non-blocking, threaded and non-threaded, recursive domain name system
                        services. The current support is limited to a stab resolver because there are DNS-standard issues which need to be resolved before
                        we are going to support recursive services. Please read the documentation files of yaadns to get more information about the DNS mess.
                        The following list shows the current yaadns services:<br />
                        <ul>
                            <li>Asynchronous,</li>
                            <li>non-threaded,</li>
                            <li>cryptographicly safe,</li>
                            <li>stab</li>
                            <li>domain name resolver</li>
                        </ul>
                    </p>
                    <p>
                        TODO: tutorials
                    </p>
                </div>
            </div>
            <div>
                <h1>Rules &amp; Guidelines</h1>
                <p>
                    Following a list of guidelines and rules all ONS software conforms to:
                    <ul>
                        <li>Use as less external dependencies as possible.</li>
                        <li>Allow the user to access everything and provide him sufficient information.</li>
                        <li>Write the source ISO-C89 compatible.</li>
                        <li>The code should be transparent and should not hide anything to the user.</li>
                        <li>All structures/datatypes ought to be the same at any platform. This does not explicitely include padding, though, some types are
                            even guaranteed to have the same padding on all platforms. This is noted in the documentation.</li>
                        <li>No tabs in the source!</li>
                        <li>Indentation is exactly 4 spaces!</li>
                        <li>Every library uses always the functionality of other ONS libraries instead of reimplementing it (eg., all libraries call
                            mem_malloc() of libmemoria instead of malloc() of libc).</li>
                        <li>A function must always be threadsafe, although, the context it operates on does not have to be threadsafe.</li>
                        <li>(TODO) To be continued...</li>
                    </ul>
                </p>
                <p>
                    All ONS software follows these rules in every form. If there is an exception it is marked explicitly in the documentation. If you have critiques
                    or suggestions to these rules and guidelines, please don't hesitate and contact us. We are glad about every feedback (Have I already said this before?).
                </p>
            </div>
        </div>
    </body>
</html>
